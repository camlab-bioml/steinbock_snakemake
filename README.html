<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>readme</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="README_files/libs/clipboard/clipboard.min.js"></script>
<script src="README_files/libs/quarto-html/quarto.js"></script>
<script src="README_files/libs/quarto-html/popper.min.js"></script>
<script src="README_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="README_files/libs/quarto-html/anchor.min.js"></script>
<link href="README_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="README_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="README_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="README_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="README_files/libs/bootstrap/bootstrap-9d6291b2c8e6b1a25733f4c9bdd3eedd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="steinbock-snakemake-v0.0.5" class="level1">
<h1>Steinbock-snakemake v0.0.5</h1>
<section id="overview" class="level2">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<p>Run the <a href="https://github.com/BodenmillerGroup/steinbock">steinbock</a> workflow as a scalable module to process raw IMC data into files usable for visualization tools and downstream analysis.</p>
<p>This pipeline uses preprocesses the mcd files, segment cells and nuclei, generate neighbors and finally outputs files required for downstream analysis.</p>
<p>The <code>steinbock</code> functionality is wrapped with <a href="https://snakemake.readthedocs.io/en/stable/">snakemake</a> to make computations more efficient and compatible with cluster and grid environments</p>
</section>
<section id="set-up-pipeline-environment-via-conda-pip" class="level2">
<h2 class="anchored" data-anchor-id="set-up-pipeline-environment-via-conda-pip">Set-up pipeline environment (via conda, pip)</h2>
<p>We will first set up the pipeline environment via conda and pip. This will install all dependencies including snakemake and singularity for use.</p>
<pre><code>git clone https://github.com/camblab-bioml/steinbock_snakemake &amp;&amp; cd steinbock_snakemake # clone git repo, then move into the pipeline folder. 
conda env create -y --file=workflow/env/environment.yml
conda activate steinbock-snakemake</code></pre>
</section>
<section id="running-steinbock-snakemake" class="level2">
<h2 class="anchored" data-anchor-id="running-steinbock-snakemake">Running Steinbock-snakemake</h2>
<section id="data-input-and-output-structures" class="level3">
<h3 class="anchored" data-anchor-id="data-input-and-output-structures">Data input and output structures</h3>
<p>Now that the containers and environment is set-up, we will run and test the pipeline on a small mcd file.</p>
<p>Use the following command to copy the test dataset into the <code>data</code> which directory:</p>
<pre class="commandline"><code>cp -r tests/test_mcd/ data/</code></pre>
<p>After copying, the structure of the input data folder should appear as follows:</p>
<pre><code>â”€â”€ ğŸ“data
    â””â”€â”€ ğŸ“test_mcd
        â””â”€â”€ ğŸ“mcd # Folder for you XTi mcd file or Hyperion mcd file. .txt files are also supported.
            â””â”€â”€ test.mcd</code></pre>
</section>
<section id="creating-a-new-project" class="level3">
<h3 class="anchored" data-anchor-id="creating-a-new-project">Creating a new project</h3>
<p>Each project is given a directory under the data folder. To create a new project, make a new folder under <code>data/yourproject</code> and add a <code>data/yourproject/mcd</code> folder. Drag and drop your <code>yourproject.mcd</code> into the mcd folder. The minimum requirement for the project folder structure is as shown:</p>
<pre><code>â”€â”€ ğŸ“data
    â””â”€â”€ ğŸ“yourproject
        â””â”€â”€ ğŸ“mcd # Folder for you XTi *.mcd file or Hyperion *.mcd file. Hyperion *.txt files are also supported.
            â””â”€â”€ test.mcd</code></pre>
</section>
<section id="preflight-configuration" class="level3">
<h3 class="anchored" data-anchor-id="preflight-configuration">Preflight configuration</h3>
<p>Before running the pipeline, we will first take a look at the configuration file <code>config/config.yaml</code>. This will store important information regarding the settings for each analysis module. The structure of the config file is as follows:</p>
<pre><code>projects:
  - test_mcd # Informs the snakemake pipeline which projects to process

# Options for mesmer_pipeline
seed: 123L
hpf: 5 # hot pixel filter
nuclear: "Ir191" # Nuclear Channel. For multiple channels the syntax is "Ir191 Ir193 Dy162"
cytoplasm: "Gd158" # Cytoplasm Channel. For multiple channels the syntax is "Ir191 Ir193 Dy162"
deepcell_app: "mesmer"
deepcell_model: "MultiplexSegmentation"
deepcell_modelpath: "/opt/keras/models"
deepcell_pxsize: 1
aggr: "mean" # Aggregation of signal. Can be either of these [mean|median]
neighbor_type: "borders" # Consideration of each neighbor
dmax: 15 # Max centroid to centroid distance 
kmax: 5 # Max number of neighbors


phenograph_k: 30 # Number of kearest neighbors to use for phenograph
phenograph_min_cluster_size: 10 # Minimum number of cells requires for a cluster to be designated as a true cluster

umap_min_dist: [0, 0.1, 0.25, 0.5, 1] # run the UMAP for every distance value passed
</code></pre>
<p>Under the <code>projects</code> configuration, add your folder name and the pipeline will process the mcd files in that folder, if you had not already done so. We will use the <code>test_mcd</code> project in this demonstration.</p>
<pre><code>projects:
    - test_mcd</code></pre>
</section>
<section id="channels-for-segmenting-cells" class="level3">
<h3 class="anchored" data-anchor-id="channels-for-segmenting-cells">Channels for segmenting cells</h3>
<p>To help mesmer segment cells, steinbock will require the user to input the mass channels for cytoplasm specific markers (e.g panCK, Actin etc). You should include those channels under <code>cytoplasm</code> and <code>nuclear</code></p>
<pre><code>nuclear: "Ir191" # Nuclear Channel. For multiple channels the syntax is "Ir191 Ir193 Dy162"
cytoplasm: "Gd158" # Cytoplasm Channel. For multiple channels the syntax is "Ir191 Ir193 Dy162" </code></pre>
</section>
<section id="extracting-features" class="level3">
<h3 class="anchored" data-anchor-id="extracting-features">Extracting features</h3>
<p>After generating segmenting masks, steinbock will proceed to extract single-cell features (intensities, neighbors, region properties etc.)</p>
<pre><code>aggr: "mean" # Aggregation of signal. Can be either of these [mean|median]
neighbor_type: "borders" # Consideration of each neighbor
dmax: 15 # Max distance
kmax: 5 # Max number of neighbors</code></pre>
</section>
<section id="downstream-channels" class="level3">
<h3 class="anchored" data-anchor-id="downstream-channels">Downstream channels</h3>
<p>Users should be cautious about which channels are selected for use in downstream analysis tasks such as UMAP projections and clustering. Certain channels such as gas channels (Argon, Xenon, etc.) can confound the cluster assignment and UMAP coordinates for IMC datasets and may not be biologically relevant. To remove these channels from these tasks, users should set the <code>channels_ignore_umap</code> config input as follows:</p>
<pre><code>channels_ignore_umap: "ArAr80 Xe126 Xe131 Xe134" # proper syntax is space separated for each channel</code></pre>
<p>In the example above, the pipeline will ignore 4 channels corresponding to gas measurements. This often leads to cleaner phenograph cluster assignments and better resolution for UMAPs. Note that this input should be changed to reflect the appropriate channel names set by the user.</p>
</section>
<section id="basic-clustering-and-dimension-reduction" class="level3">
<h3 class="anchored" data-anchor-id="basic-clustering-and-dimension-reduction">Basic clustering and dimension reduction</h3>
<p>The steinbock pipeline will additionally perform basic subpopulation cluster analysis using <a href="https://github.com/dpeerlab/phenograph">phenograph</a> and dimension reduction with <a href="https://github.com/lmcinnes/umap">UMAP</a>. The following parameters in the configuration file control the behavior of the phenograph clustering algorithm:</p>
<pre><code>phenograph_k: 30 # Number of kearest neighbors to use for phenograph
phenograph_min_cluster_size: 10 # Minimum number of cells requires for a cluster to be designated as a true cluster</code></pre>
<p>The exported anndata object that follows the naming pattern <code>{project}.h5ad</code> will contain these outputs in the following anndata slots:</p>
<ul>
<li>clustering will be found in the <code>phenograph</code> column of the <code>obs</code> slot</li>
</ul>
</section>
<section id="umap" class="level3">
<h3 class="anchored" data-anchor-id="umap">UMAP</h3>
<p>The pipeline will be default run UMAP with the following minimum distance values between 0 and 1: 0, 0.1, 0.25, 0.5, 1. These values can be changed by passing a list of values in the config as â€˜umap_min_distâ€™;</p>
<pre><code>umap_min_dist: [0, 0.1, 0.25, 0.5, 1] # run the UMAP for every distance value passed</code></pre>
<p>smaller UMAP distance values produce tighter more dispersed clusters, while larger values create fewer clusters and a more uniform manifold.</p>
<p>The UMAP coordinates for every distance used are stored in the <code>umap</code> sub-directory of the <code>export</code> output directory. Each distance is also plotted alongside the phenograph clustering to give users a general idea of cluster dispersion for different distance metrics.</p>
</section>
<section id="project-specific-configuration" class="level3">
<h3 class="anchored" data-anchor-id="project-specific-configuration">Project specific configuration</h3>
<p>After editing <code>config.yml</code>, we would want to ensure we use the same settings for each project. A simple solution is to copy the <code>config.yml</code> file over to the project directory before calling the snakemake, and directing it to the config file.</p>
<pre><code>cp config/config.yaml data/test_mcd/test_mcd.yaml</code></pre>
</section>
<section id="running-the-snakemake-pipeline" class="level3">
<h3 class="anchored" data-anchor-id="running-the-snakemake-pipeline">Running the snakemake pipeline</h3>
<p>After completing the preflight configuration, we can run the pipeline. The <code>snakemake</code> command is invoked in the <code>steinbock-snakemake</code> directory: 1. Specify cores required using the <code>-c</code> flag. 2. Specify the configuration file to use using the <code>--configfile</code> flag.</p>
<pre><code>cd ~/test_folder/steinbock_snakemake # navigate to the main directory where it is cloned
snakemake -c 4 --configfile data/test_mcd/test_mcd.yaml</code></pre>
</section>
<section id="inspect-pipeline-outputs" class="level3">
<h3 class="anchored" data-anchor-id="inspect-pipeline-outputs">Inspect pipeline outputs</h3>
<p>This concludes this tutorial!</p>
<p>The pipeline output directory structure for the current version is as follows:</p>
<pre><code>â””â”€â”€ ğŸ“test_mcd
    â””â”€â”€ ğŸ“deepcell # outputs for deepcell segmentation and masks per ROI
        â””â”€â”€ ğŸ“intensities
            â””â”€â”€ test_018.csv
        â””â”€â”€ ğŸ“neighbors
            â””â”€â”€ test_018.csv
        â””â”€â”€ ğŸ“nuclei
            â””â”€â”€ test_018.tiff
        â””â”€â”€ ğŸ“regionprops
            â””â”€â”€ test_018.csv
        â””â”€â”€ ğŸ“whole_cell
            â””â”€â”€ test_018.tiff
    â””â”€â”€ ğŸ“export # Exports per channel tiff for each ROI, an ome.tiff file and a anndata object
        â””â”€â”€ ğŸ“test_018
            â””â”€â”€ ArAr80_80ArAr.tiff
            â””â”€â”€ Dy162_162Dy_h5454_Chr10SAT.tiff
            â””â”€â”€ Er166_166Er_h3838_Chr1SAT.tiff
            â””â”€â”€ Er167_167Er_h3838_Chr1SAT.tiff
            â””â”€â”€ Gd158_158Gd_h5050_Chr2SAT.tiff
            â””â”€â”€ Ir191_191Ir_DNA1.tiff
            â””â”€â”€ Ir193_193Ir_DNA2.tiff
            â””â”€â”€ Pb206_206Pb.tiff
            â””â”€â”€ Pb208_208Pb.tiff
            â””â”€â”€ Xe126_126Xe.tiff
            â””â”€â”€ Xe131_131Xe.tiff
            â””â”€â”€ Xe134_134Xe.tiff
            â””â”€â”€ test_018_mask.tiff
        â””â”€â”€ test_018.ome.tiff
        â””â”€â”€ test_mcd.h5ad
        â””â”€â”€ scaling.json #used for rakaia visualization
        â””â”€â”€ ğŸ“umap
            â””â”€â”€ umap_min_dist...coordinates.csv
            â””â”€â”€ umap_min_dist...png
    â””â”€â”€ ğŸ“img # Multichannel Tiff folder
        â””â”€â”€ images.csv
        â””â”€â”€ test_018.tiff
    â””â”€â”€ ğŸ“mcd
        â””â”€â”€ test.mcd
    â””â”€â”€ panel.csv # panel file containing all markers
    â””â”€â”€ panel_deepcell.csv # panel file containing markers for nuclear and cytoplasm segmentation
    â””â”€â”€ test_mcd.yaml</code></pre>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>